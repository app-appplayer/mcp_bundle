/// Canonical Claim type for verifiable assertions.
///
/// Claims are the bridge between skill execution (mcp_skill) and
/// knowledge persistence (mcp_fact_graph).
library;

/// Semantic type of the claim content.
enum ClaimType {
  // Factual types
  fact,
  date,
  amount,
  quantity,
  category,
  entity,
  relation,

  // Derived types
  conclusion,
  recommendation,
  speculation,
  observation;

  static ClaimType fromString(String value) {
    return ClaimType.values.firstWhere(
      (e) => e.name == value.toLowerCase(),
      orElse: () => throw ArgumentError('Unknown claim type: $value'),
    );
  }
}

/// Validation state of the claim.
enum ClaimStatus {
  pending,
  supported,
  unsupported,
  conflicting,
  speculation;

  static ClaimStatus fromString(String value) {
    return ClaimStatus.values.firstWhere(
      (e) => e.name == value.toLowerCase(),
      orElse: () => throw ArgumentError('Unknown claim status: $value'),
    );
  }
}

/// A verifiable assertion extracted from content or generated by skill execution.
class Claim {
  /// Unique claim identifier (UUID).
  final String id;

  /// Human-readable claim text.
  final String text;

  /// Semantic type of the claim.
  final ClaimType type;

  /// Structured value (parsed from text).
  final dynamic value;

  /// Source context (responseId, skillRunId, etc.).
  final String? sourceId;

  /// Evidence IDs supporting this claim.
  final List<String> evidenceRefs;

  /// Confidence score (0.0 to 1.0).
  final double confidence;

  /// Validation status.
  final ClaimStatus status;

  /// If status is 'conflicting', explains why.
  final String? conflictReason;

  /// Creation timestamp.
  final DateTime? createdAt;

  /// Additional context-specific data.
  final Map<String, dynamic>? metadata;

  const Claim({
    required this.id,
    required this.text,
    required this.type,
    this.value,
    this.sourceId,
    required this.evidenceRefs,
    required this.confidence,
    this.status = ClaimStatus.pending,
    this.conflictReason,
    this.createdAt,
    this.metadata,
  });

  /// Parse from JSON.
  factory Claim.fromJson(Map<String, dynamic> json) {
    return Claim(
      id: json['id'] as String,
      text: json['text'] as String,
      type: ClaimType.fromString(json['type'] as String),
      value: json['value'],
      sourceId: json['sourceId'] as String?,
      evidenceRefs: (json['evidenceRefs'] as List<dynamic>?)
              ?.map((e) => e as String)
              .toList() ??
          [],
      confidence: (json['confidence'] as num).toDouble(),
      status: json['status'] != null
          ? ClaimStatus.fromString(json['status'] as String)
          : ClaimStatus.pending,
      conflictReason: json['conflictReason'] as String?,
      createdAt: json['createdAt'] != null
          ? DateTime.parse(json['createdAt'] as String)
          : null,
      metadata: json['metadata'] as Map<String, dynamic>?,
    );
  }

  /// Convert to JSON.
  Map<String, dynamic> toJson() => {
        'id': id,
        'text': text,
        'type': type.name,
        if (value != null) 'value': value,
        if (sourceId != null) 'sourceId': sourceId,
        'evidenceRefs': evidenceRefs,
        'confidence': confidence,
        'status': status.name,
        if (conflictReason != null) 'conflictReason': conflictReason,
        if (createdAt != null) 'createdAt': createdAt!.toIso8601String(),
        if (metadata != null) 'metadata': metadata,
      };

  /// Create a copy with updated fields.
  Claim copyWith({
    String? id,
    String? text,
    ClaimType? type,
    dynamic value,
    String? sourceId,
    List<String>? evidenceRefs,
    double? confidence,
    ClaimStatus? status,
    String? conflictReason,
    DateTime? createdAt,
    Map<String, dynamic>? metadata,
  }) {
    return Claim(
      id: id ?? this.id,
      text: text ?? this.text,
      type: type ?? this.type,
      value: value ?? this.value,
      sourceId: sourceId ?? this.sourceId,
      evidenceRefs: evidenceRefs ?? this.evidenceRefs,
      confidence: confidence ?? this.confidence,
      status: status ?? this.status,
      conflictReason: conflictReason ?? this.conflictReason,
      createdAt: createdAt ?? this.createdAt,
      metadata: metadata ?? this.metadata,
    );
  }

  @override
  String toString() => 'Claim($id: $text)';

  @override
  bool operator ==(Object other) =>
      identical(this, other) || other is Claim && id == other.id;

  @override
  int get hashCode => id.hashCode;
}
